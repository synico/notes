## JVM运行时数据区
![jvm](../images/jvm.png)
***
![jvm](../images/jvm_rda_size.png)
***

### 虚拟机栈 (VM Stack)
* 虚拟机栈生命周期与线程相同，它描述Java方法执行的内存模型。
* 每个方法在执行的同时都会创建一个栈帧来存储局部变量表，操作数栈，动态连接和方法出口信息。
* 每个方法从调用到执行完毕的过程，对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
#### 1. 局部变量表 (Local Variable Table)
局部变量表是一组变量值存储空间，用于存储方法参数和方法内定义的局部变量。
* 局部变量表的容量以变量槽 (variable slot) 为最小单位。
* 局部变量表中的slot是可以重用的，但是在某些特定情况下slot复用 (某slot在被复用前，作为GC Roots的一部分的局部变量表仍保持着对该slot的引用) 会直接影响到系统的垃圾回收行为。
* 类变量在准备阶段，赋予系统初始值，并在初始化阶段赋予程序中定义的值。而局部变量则不同，局部变量没有以上两个阶段，所以局部变量定义了但是没有赋初始值是不能使用的。
#### 2. 操作数栈 (Operand Stack)
操作数栈也常称为操作栈，是一个后入先出 (LIFO) 栈。方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，即入栈出栈操作。例如，做算术运算时是通过操作数栈进行，又或在调用其它方法时通过操作数栈进行参数传递。
#### 3. 动态连接 (Dynamic Linking)
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
#### 4. 返回地址 (Return Address)
##### 方法执行后可能有两种退出方式
* 正常完成出口: 执行引擎遇到一个方法返回的字节码指令，此时如有返回值，则将返回值返回给上层调用者。
* 异常完成出口: 方法执行遇到没有在本方法异常表中定义的异常，即遇到未处理的异常时，会导致方法退出，并且不返回任何值给上层调用者。
##### 方法返回时可能执行的操作
* 恢复上层调用方法的局部变量表和操作栈。
* 将返回值压入上层方法的操作栈。
* 调整程序计数器的值以指向方法调用指令后面的一条指令。
***

### 本地方法栈 (Native Method Stack)
为虚拟机使用的Native方法服务，与虚拟机栈的作用类似。
***

### 程序计数器 (Program Counter Register)
* 虚拟机概念模型里，字节码解释器工作时通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能。
* 多线程是通过线程轮流切换并分配处理器执行时间的方式来实现。
* 每个线程有一个独立的程序计数器，保证线程切换后能恢复到正确的执行位置。为线程私有的内存区域。
* 虚拟机规范中唯一没有规定任何OutOfMemoryError情况的区域。
***

### 方法区 (Method Area)
#### 元空间 (Metaspace)
JDK8以后，方法区的实现由永久代被完全替换成元空间。类的元数据仍存储在方法区新的实现中，即在元空间内。
* 方法区的新实现元空间不再分配在虚拟机内存中，而是分配到本地内存。因此类的元数据也从虚拟机中移到了本地内存中。
* 当使用的元空间大小超过预设的MetaspaceSize时，会触发GC进行类型卸载，包括类和类加载器。
* Classloader leak仍然存在。
#### 永久代 (PermGen)
JDK8之前某些JVM中方法区的实现被称为永久代 (Permanent Generation)，被各个线程共享的存储区域。用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
* 通过JDK动态代理或CGLib这类字节码增强技术，生成的动态Class存放在方法区。
* JVM上动态语言，如Groovy创建的类也存放在方法区。
###### 运行时常量池 (Runtime Constant Pool)
作为方法区的一部分，用于存储编译器生成的各种字面量和符号引用。
* JDK6中常量池存储在常量池。
* JDK7以后常量池存储在堆中。
***

### 堆 (Heap)
被所有线程共享的存储区域，用来存储对象实例，分为新生代，老年代两大部分。
#### 新生代 (Young Generation)
新生代又分为三部分。
* Eden空间: 新创建的对象实例，优先分配在Eden区，如启动了本地线程分配缓冲，则按线程优先级在TLAB上分配空间。
* From/To Survivor空间: 存储Minor GC后仍存活的对象。
#### 老年代 (Old Generation)
需要大量连续内存空间的对象实例，如很长的字符串或数组，创建后直接进入老年代。
***

### 直接内存 (Direct Memory)
* 不是JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域。但这部分内存也被频繁使用，也会造成抛出OOM异常。
* JDK1.4引入的NIO，一种基于通道与缓冲区的IO操作方式，可以使用native函数库直接分配堆外内存。并通过堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免在堆和本地堆直接来回复制数据。
***

### JDK工具箱
#### jps
类似UNIX的ps命令，列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一LVMID (Local Virtual Machine Identifier) 。
#### jstat
用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据。
#### jinfo
实时查看和调整虚拟机各项参数。
#### jmap
用于生成堆转存储快照，一般称为heapdump或dump文件。除此之外还可以设置-XX:+HeapDumpOnOutOfMemoryError参数，让虚拟机在OOM异常出现之后自动生成dump文件。或在Linux系统下通过kill -3命令发送进程退出信号。
#### jstack
用于生成虚拟机当前时刻的线程快照，一般称为threaddump或者javacore文件。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，可用来定位线程出现长时间停顿的原因，如线程死锁，死循环，请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。
#### jconsole
#### visualvm
